import json
import base64
import io
import boto3
import fastavro
from fastavro.schema import load_schema
from confluent_kafka.schema_registry import SchemaRegistryClient
from confluent_kafka.schema_registry.avro import AvroSerializer

SCHEMA_REGISTRY_URL = ''
SCHEMA_REGISTRY_API_KEY = ''
RAW_OUTBOUND_TOPIC = ''

class SerializationContext:
    def __init__(self, topic, field=None):
        self.topic = topic
        self.field = field

def topic_record_subject_name_strategy(ctx, schema_name):
    return f"{ctx.topic}-{ctx.field}"

class AvroSerializerWrapper:
    def __init__(self, processing_event_type: str):
        self.processing_event_type = processing_event_type
        self.schema_registry_conf = {
            'url': SCHEMA_REGISTRY_URL,
            'basic.auth.user.info': SCHEMA_REGISTRY_API_KEY
        }
        self.value_serializer = self._create_serializer('value')

    def _create_serializer(self, field):
        schema_registry_client = SchemaRegistryClient(self.schema_registry_conf)
        schema_name = f"{self.processing_event_type}-{field}"
        try:
            schema = schema_registry_client.get_latest_version(schema_name)
            return AvroSerializer(
                schema_registry_client,
                schema.schema.schema_str,
                conf={
                    "auto.register.schemas": False,
                    "subject.name.strategy": topic_record_subject_name_strategy,
                },
            )
        except Exception as e:
            print(f"Error creating Avro serializer for {field}: {str(e)}")
            raise

    def serialize_value(self, topic_name: str, value: Any):
        value_context = SerializationContext(topic_name, field="value")
        serialized_value = self.value_serializer(value, value_context)
        base64_value = base64.b64encode(serialized_value).decode('utf-8')
        return base64_value

def read_json(file_path):
    with open(file_path, 'r') as file:
        return json.load(file)

def base64_encode(data):
    return base64.b64encode(data).decode('utf-8')

def encode_headers(headers):
    encoded_headers = []
    for header in headers:
        key = header['key']
        value = header.get('value')
        if value is None:
            encoded_value = []
        else:
            encoded_value = list(value.encode())
        encoded_headers.append({key: encoded_value})
    return encoded_headers

def format_message(json_message, processing_event_type):
    key = base64_encode(json_message['key'].encode())
    avro_serializer = AvroSerializerWrapper(processing_event_type)
    value = avro_serializer.serialize_value(RAW_OUTBOUND_TOPIC, json_message['value'])
    headers = encode_headers(json_message['headers'])
    formatted_message = {
        "eventSource": "",
        "bootstrapServers": "",
        "records": {
            "": [
                {
                    "topic": "",
                    "partition": json_message['partition'],
                    "offset": json_message['offset'],
                    "timestamp": json_message['timestamp'],
                    "timestampType": json_message['timestampType'],
                    "key": key,
                    "value": value,
                    "headers": headers
                }
            ]
        }
    }
    return formatted_message

def invoke_lambda(lambda_function_name, payload):
    lambda_client = boto3.client('lambda')
    response = lambda_client.invoke(
        FunctionName=lambda_function_name,
        InvocationType='RequestResponse',
        Payload=json.dumps(payload)
    )
    return json.loads(response['Payload'].read().decode('utf-8'))

def write_to_output_file(output_file_path, formatted_message):
    with open(output_file_path, 'w') as output_file:
        json.dump(formatted_message, output_file, indent=4)

def main():
    json_file_path = ''
    output_file_path = ''
    lambda_function_name = 'your_lambda_function_name'

    json_message = read_json(json_file_path)
    processing_event_type = ""
    formatted_message = format_message(json_message, processing_event_type)

    lambda_response = invoke_lambda(lambda_function_name, formatted_message)
    print(f"Lambda response: {lambda_response}")

    write_to_output_file(output_file_path, formatted_message)
    print(f"Formatted message written to {output_file_path}")

if __name__ == '__main__':
    main()
